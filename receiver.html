<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawblins Cast Receiver</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }
        
        .cast-display {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }
        
        /* Header with room code and timer */
        .cast-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2rem 4rem;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            flex-shrink: 0;
        }
        
        .cast-title {
            font-size: 3rem;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .cast-timer {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 1.5rem 3rem;
            border-radius: 40px;
            font-size: 3rem;
            font-weight: bold;
            min-width: 200px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        
        .cast-timer.timer-urgent {
            background: #e74c3c;
        }
        
        .cast-room-info {
            text-align: right;
        }
        
        .cast-room-code {
            font-size: 1.2rem;
            opacity: 0.8;
            margin: 0;
        }
        
        .cast-room-code-value {
            font-family: 'Courier New', monospace;
            font-size: 2rem;
            font-weight: bold;
            margin: 0.5rem 0 0 0;
            letter-spacing: 3px;
        }
        
        /* Main content area */
        .cast-content {
            flex: 1;
            padding: 3rem 4rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            overflow-y: auto;
        }
        
        .cast-phase-info {
            text-align: center;
            margin-bottom: 3rem;
        }
        
        .cast-phase-title {
            font-size: 4rem;
            margin: 0 0 1rem 0;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.4);
            font-weight: bold;
        }
        
        .cast-phase-subtitle {
            font-size: 1.8rem;
            margin: 0;
            opacity: 0.9;
            font-weight: 300;
        }
        
        .cast-current-player {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 20px;
            padding: 2rem 3rem;
            margin: 2rem 0;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .cast-player-name {
            font-size: 2.5rem;
            margin: 0 0 0.5rem 0;
            color: #FFD700;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .cast-player-action {
            font-size: 1.4rem;
            margin: 0;
            opacity: 0.9;
        }
        
        .cast-progress-info {
            background: rgba(255, 152, 0, 0.2);
            border-radius: 15px;
            padding: 1.5rem 2rem;
            margin: 1rem 0;
            text-align: center;
            border: 1px solid rgba(255, 152, 0, 0.3);
        }
        
        .cast-progress-text {
            font-size: 1.6rem;
            margin: 0;
            font-weight: bold;
        }
        
        /* Drawings gallery */
        .cast-drawings-section {
            margin-top: 2rem;
        }
        
        .cast-drawings-title {
            font-size: 2.5rem;
            text-align: center;
            margin: 0 0 2rem 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .cast-drawings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 2rem;
            margin: 2rem 0;
        }
        
        .cast-original-monster {
            background: linear-gradient(135deg, #FFD700, #FFA500);
            border: 4px solid #FF8C00;
            border-radius: 20px;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 12px 40px rgba(0,0,0,0.3);
            transform: scale(1.05);
        }
        
        .cast-original-monster h3 {
            color: #8B4513;
            margin: 0 0 1rem 0;
            font-weight: bold;
            font-size: 1.6rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }
        
        .cast-player-drawing {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 2rem;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            transition: transform 0.2s ease;
        }
        
        .cast-player-drawing:hover {
            transform: translateY(-5px);
        }
        
        .cast-player-drawing h3 {
            color: #333;
            margin: 0 0 1rem 0;
            font-size: 1.3rem;
            font-weight: bold;
        }
        
        .cast-drawing-image {
            width: 100%;
            height: 220px;
            object-fit: contain;
            border-radius: 12px;
            border: 2px solid rgba(0,0,0,0.1);
            background: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .cast-auto-submitted-badge {
            display: inline-block;
            background: #95a5a6;
            color: white;
            padding: 0.3rem 0.8rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-left: 0.5rem;
        }
        
        /* Connection states */
        .cast-connecting {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            text-align: center;
        }
        
        .cast-connecting h2 {
            font-size: 3rem;
            margin: 0 0 1rem 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .cast-connecting p {
            font-size: 1.5rem;
            opacity: 0.8;
            margin: 0;
        }
        
        .cast-loading-spinner {
            width: 60px;
            height: 60px;
            border: 6px solid rgba(255,255,255,0.3);
            border-top: 6px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 2rem 0;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .hidden { 
            display: none !important; 
        }
        
        /* Image loading states */
        .cast-drawing-image {
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .cast-drawing-image.loaded {
            opacity: 1;
        }
        
        .cast-drawing-placeholder {
            width: 100%;
            height: 220px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.1);
            border-radius: 12px;
            color: #666;
            font-size: 0.9rem;
        }
        
        /* Responsive for different TV sizes */
        @media (max-width: 1200px) {
            .cast-header {
                padding: 2rem 3rem;
            }
            
            .cast-timer {
                font-size: 2.5rem;
                padding: 1.2rem 2.5rem;
                min-width: 160px;
            }
            
            .cast-phase-title {
                font-size: 3rem;
            }
            
            .cast-player-name {
                font-size: 2rem;
            }
            
            .cast-drawings-grid {
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                gap: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="cast-display">
        <!-- Header -->
        <div class="cast-header">
            <div class="cast-title">Drawblins</div>
            <div class="cast-timer" id="cast-timer">00:00</div>
            <div class="cast-room-info">
                <p class="cast-room-code">Room Code:</p>
                <p class="cast-room-code-value" id="cast-room-code">----</p>
            </div>
        </div>
        
        <!-- Main content -->
        <div class="cast-content">
            <!-- Connecting state -->
            <div id="cast-connecting" class="cast-connecting">
                <div class="cast-loading-spinner"></div>
                <h2>Connecting to Game...</h2>
                <p>Waiting for players to join</p>
            </div>
            
            <!-- Game content -->
            <div id="cast-game-content" class="hidden">
                <div class="cast-phase-info">
                    <h1 class="cast-phase-title" id="cast-phase-title">Welcome to Drawblins!</h1>
                    <p class="cast-phase-subtitle" id="cast-phase-subtitle">Get ready to play</p>
                </div>
                
                <div id="cast-current-player" class="cast-current-player hidden">
                    <h2 class="cast-player-name" id="cast-player-name">Player Name</h2>
                    <p class="cast-player-action" id="cast-player-action">is getting ready</p>
                </div>
                
                <div id="cast-progress" class="cast-progress-info hidden">
                    <p class="cast-progress-text">
                        Drawings submitted: <span id="cast-progress-count">0</span> / <span id="cast-progress-total">0</span>
                    </p>
                </div>
            </div>
            
            <!-- Drawings display -->
            <div id="cast-drawings" class="cast-drawings-section hidden">
                <h2 class="cast-drawings-title">Round Results!</h2>
                <div id="cast-drawings-grid" class="cast-drawings-grid">
                    <!-- Drawings will be inserted here -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Cast SDK -->
    <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
    
    <script>
        // Cast Application Framework setup
        const context = cast.framework.CastReceiverContext.getInstance();
        const playerManager = context.getPlayerManager();
        
        // Game state
        let gameState = null;
        let room = null;
        let roomCode = null;
        
        // Image handling
        const imageCache = new Map();
        const IMAGE_BASE_URLS = [
            'https://teejaywilliamson.github.io/Drawblins/images/',
            './images/',
            '../images/',
            'images/'
        ];
        
        // Custom message bus for game data
        const CUSTOM_CHANNEL = 'urn:x-cast:com.drawblins.gamedata';
        
        // Chunked drawings handling
        let pendingDrawings = [];
        let expectedDrawings = 0;
        let pendingOriginalMonster = null;
        
        context.addCustomMessageListener(CUSTOM_CHANNEL, (customEvent) => {
            const message = customEvent.data;
            console.log('Received custom message:', message);
            
            switch (message.type) {
                case 'game-update':
                    handleGameUpdate(message.gameState, message.room);
                    break;
                case 'timer-update':
                    updateTimer(message.timeString, message.timeLeft);
                    break;
                case 'show-drawings':
                    showDrawingsResults(message.drawings, message.originalMonster);
                    break;
                case 'show-drawings-start':
                    console.log('📦 Starting chunked drawings reception...');
                    pendingDrawings = [];
                    expectedDrawings = message.totalDrawings;
                    pendingOriginalMonster = message.originalMonster;
                    break;
                case 'show-drawing-chunk':
                    console.log(`📥 Received drawing chunk ${message.index + 1}/${expectedDrawings}`);
                    pendingDrawings[message.index] = message.drawing;
                    
                    if (message.isLast || pendingDrawings.filter(d => d).length === expectedDrawings) {
                        console.log('📦 All drawing chunks received, displaying...');
                        showDrawingsResults(pendingDrawings.filter(d => d), pendingOriginalMonster);
                    }
                    break;
                case 'show-drawings-complete':
                    console.log('✅ Drawings reception complete');
                    break;
                case 'room-code':
                    setRoomCode(message.roomCode);
                    break;
            }
        });
        
        // Image loading utility
        function loadImageWithFallbacks(imageName, callback) {
            if (imageCache.has(imageName)) {
                callback(imageCache.get(imageName), null);
                return;
            }
            
            let currentUrlIndex = 0;
            
            function tryNextUrl() {
                if (currentUrlIndex >= IMAGE_BASE_URLS.length) {
                    console.error('Failed to load image after trying all URLs:', imageName);
                    callback(null, 'Failed to load image');
                    return;
                }
                
                const url = IMAGE_BASE_URLS[currentUrlIndex] + imageName;
                console.log(`Trying to load image from: ${url}`);
                
                const img = new Image();
                
                img.onload = function() {
                    console.log(`Successfully loaded image from: ${url}`);
                    imageCache.set(imageName, url);
                    callback(url, null);
                };
                
                img.onerror = function() {
                    console.log(`Failed to load image from: ${url}`);
                    currentUrlIndex++;
                    tryNextUrl();
                };
                
                img.src = url;
            }
            
            tryNextUrl();
        }
        
        // Handle game updates
        function handleGameUpdate(newGameState, newRoom) {
            gameState = newGameState;
            room = newRoom;
            
            if (room && room.code) {
                setRoomCode(room.code);
            }
            
            updateCastDisplay();
        }
        
        function setRoomCode(code) {
            roomCode = code;
            document.getElementById('cast-room-code').textContent = code || '----';
        }
        
        function showConnecting() {
            document.getElementById('cast-connecting').classList.remove('hidden');
            document.getElementById('cast-game-content').classList.add('hidden');
            document.getElementById('cast-drawings').classList.add('hidden');
        }
        
        function showGameContent() {
            document.getElementById('cast-connecting').classList.add('hidden');
            document.getElementById('cast-game-content').classList.remove('hidden');
            document.getElementById('cast-drawings').classList.add('hidden');
        }
        
        function updateCastDisplay() {
            if (!gameState || !room) {
                showConnecting();
                return;
            }
            
            showGameContent();
            
            const currentPlayer = room.players.find(p => p.id === gameState.currentDrawer);
            
            // Update phase info
            const phaseTitle = document.getElementById('cast-phase-title');
            const phaseSubtitle = document.getElementById('cast-phase-subtitle');
            const currentPlayerDiv = document.getElementById('cast-current-player');
            const progressDiv = document.getElementById('cast-progress');
            
            switch (gameState.phase) {
                case 'studying':
                    phaseTitle.textContent = `Round ${gameState.currentRound} - Study Phase`;
                    phaseSubtitle.textContent = 'Player is memorizing the monster';
                    
                    if (currentPlayer) {
                        document.getElementById('cast-player-name').textContent = currentPlayer.name;
                        document.getElementById('cast-player-action').textContent = 'is studying the monster';
                        currentPlayerDiv.classList.remove('hidden');
                    }
                    
                    progressDiv.classList.add('hidden');
                    break;
                    
                case 'drawing':
                    phaseTitle.textContent = `Round ${gameState.currentRound} - Drawing Phase`;
                    phaseSubtitle.textContent = 'Draw what you hear!';
                    
                    if (currentPlayer) {
                        document.getElementById('cast-player-name').textContent = currentPlayer.name;
                        document.getElementById('cast-player-action').textContent = 'is describing the monster';
                        currentPlayerDiv.classList.remove('hidden');
                    }
                    
                    // Update progress
                    const expectedSubmissions = room.players.filter(p => p.id !== gameState.currentDrawer).length;
                    document.getElementById('cast-progress-count').textContent = gameState.drawings?.length || 0;
                    document.getElementById('cast-progress-total').textContent = expectedSubmissions;
                    progressDiv.classList.remove('hidden');
                    break;
                    
                case 'reveal':
                    showDrawingsResults(gameState.drawings, gameState.currentMonster);
                    return;
                    
                default:
                    phaseTitle.textContent = 'Drawblins Party Mode';
                    phaseSubtitle.textContent = 'Waiting for game to start...';
                    currentPlayerDiv.classList.add('hidden');
                    progressDiv.classList.add('hidden');
            }
        }
        
function showDrawingsResults(drawings, originalMonster) {
            console.log('🎨 === SHOWING DRAWINGS RESULTS ===');
            console.log('📊 Drawings received:', drawings);
            console.log('📊 Drawings count:', drawings?.length || 0);
            console.log('📊 Original monster:', originalMonster);
            
            // Log each drawing data
            if (drawings && drawings.length > 0) {
                drawings.forEach((drawing, index) => {
                    console.log(`📊 Drawing ${index + 1}:`, {
                        playerName: drawing.playerName,
                        hasImageData: !!drawing.imageData,
                        imageDataLength: drawing.imageData?.length || 0,
                        imageDataPreview: drawing.imageData?.substring(0, 50) + '...'
                    });
                });
            }
            
            document.getElementById('cast-connecting').classList.add('hidden');
            document.getElementById('cast-game-content').classList.add('hidden');
            document.getElementById('cast-drawings').classList.remove('hidden');
            
            const grid = document.getElementById('cast-drawings-grid');
            grid.innerHTML = '';
            
            // Add original monster first
            if (originalMonster) {
                console.log('🖼️ Adding original monster:', originalMonster);
                const originalDiv = document.createElement('div');
                originalDiv.className = 'cast-original-monster';
                
                // Create placeholder first
                originalDiv.innerHTML = `
                    <h3>Original Monster</h3>
                    <div class="cast-drawing-placeholder">Loading original monster...</div>
                `;
                grid.appendChild(originalDiv);
                
                // Load image with fallbacks
                loadImageWithFallbacks(originalMonster, (imageUrl, error) => {
                    const placeholder = originalDiv.querySelector('.cast-drawing-placeholder');
                    if (imageUrl) {
                        const img = document.createElement('img');
                        img.className = 'cast-drawing-image';
                        img.alt = 'Original Monster';
                        img.onload = () => {
                            console.log('✅ Original monster image loaded successfully');
                            img.classList.add('loaded');
                        };
                        img.onerror = () => {
                            console.error('❌ Failed to load original monster image');
                        };
                        img.src = imageUrl;
                        placeholder.replaceWith(img);
                    } else {
                        console.error('❌ No image URL for original monster');
                        placeholder.textContent = 'Failed to load original monster';
                        placeholder.style.color = '#e74c3c';
                    }
                });
            }
            
            // Add player drawings
            if (drawings && drawings.length > 0) {
                console.log('🖼️ Adding player drawings:', drawings.length);
                drawings.forEach((drawing, index) => {
                    console.log(`🖼️ Processing drawing ${index + 1} for ${drawing.playerName}`);
                    
                    const drawingDiv = document.createElement('div');
                    drawingDiv.className = 'cast-player-drawing';
                    
                    // Create with placeholder first
                    drawingDiv.innerHTML = `
                        <h3>
                            ${drawing.playerName}
                            ${drawing.autoSubmitted ? '<span class="cast-auto-submitted-badge">Auto</span>' : ''}
                        </h3>
                        <div class="cast-drawing-placeholder">Loading drawing...</div>
                    `;
                    grid.appendChild(drawingDiv);
                    
                    // Load the drawing image
                    if (drawing.imageData) {
                        console.log(`🖼️ Loading image data for ${drawing.playerName} (${drawing.imageData.length} chars)`);
                        const placeholder = drawingDiv.querySelector('.cast-drawing-placeholder');
                        const img = document.createElement('img');
                        img.className = 'cast-drawing-image';
                        img.alt = `${drawing.playerName}'s drawing`;
                        
                        img.onload = () => {
                            console.log(`✅ Successfully loaded drawing for ${drawing.playerName}`);
                            img.classList.add('loaded');
                        };
                        
                        img.onerror = (error) => {
                            console.error(`❌ Failed to load drawing for ${drawing.playerName}:`, error);
                            console.error('❌ Image data preview:', drawing.imageData.substring(0, 100));
                            placeholder.textContent = 'Failed to load drawing';
                            placeholder.style.color = '#e74c3c';
                        };
                        
                        // Validate image data format
                        if (drawing.imageData.startsWith('data:image/')) {
                            console.log(`✅ Valid image data format for ${drawing.playerName}`);
                            img.src = drawing.imageData;
                            placeholder.replaceWith(img);
                        } else {
                            console.error(`❌ Invalid image data format for ${drawing.playerName}:`, drawing.imageData.substring(0, 50));
                            placeholder.textContent = 'Invalid image format';
                            placeholder.style.color = '#e74c3c';
                        }
                    } else {
                        console.error(`❌ No image data for ${drawing.playerName}`);
                        const placeholder = drawingDiv.querySelector('.cast-drawing-placeholder');
                        placeholder.textContent = 'No drawing data';
                        placeholder.style.color = '#f39c12';
                    }
                });
            } else {
                console.log('❌ No drawings to display');
                const noDrawingsDiv = document.createElement('div');
                noDrawingsDiv.style.textAlign = 'center';
                noDrawingsDiv.style.fontSize = '1.5rem';
                noDrawingsDiv.style.color = '#f39c12';
                noDrawingsDiv.style.gridColumn = '1 / -1';
                noDrawingsDiv.textContent = 'No drawings received';
                grid.appendChild(noDrawingsDiv);
            }
        }
        
        function updateTimer(timeString, timeLeft) {
            const timerElement = document.getElementById('cast-timer');
            if (timerElement) {
                timerElement.textContent = timeString;
                
                // Add urgent class for last 10 seconds
                if (timeLeft <= 10 && timeLeft > 0) {
                    timerElement.classList.add('timer-urgent');
                } else {
                    timerElement.classList.remove('timer-urgent');
                }
            }
        }
        
        // Start the receiver
        context.start({
            // Disable idle timeout for long games
            maxInactivity: 3600 // 1 hour
        });
        
        // Show connecting state initially
        showConnecting();
        
        console.log('Drawblins Cast Receiver initialized');
    </script>
</body>
</html>